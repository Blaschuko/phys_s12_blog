<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/phys_s12_blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/phys_s12_blog/" rel="alternate" type="text/html" /><updated>2023-07-24T15:48:22-04:00</updated><id>http://localhost:4000/phys_s12_blog/feed.xml</id><title type="html">Blas Kozicki PHYS S-12 2023 Blog</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Output devices, making things do things</title><link href="http://localhost:4000/phys_s12_blog/2023/07/18/week7.html" rel="alternate" type="text/html" title="Output devices, making things do things" /><published>2023-07-18T00:00:00-04:00</published><updated>2023-07-18T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/07/18/week7</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/07/18/week7.html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js&quot;&gt;&lt;/script&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Choosing an output device&lt;/h2&gt;


&lt;p class=&quot;mb-p&quot;&gt;The first part of this week&apos;s assignment is to choose and use an output device using a microcontroller.
  My &lt;a href=&quot;/phys_s12_blog/finalproject.html&quot; class=&quot;link&quot;&gt;final project&lt;/a&gt; requires some way to show its
  status in realtime to the user, so I decided to try to use an RGB LED. &lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/rgb_config.png&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;This image shows us that the longest leg is the common ground, the first leg corresponds to red, the
  third one to blue, and the fourth to green.&lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;As many probably know, the color blue has a higher wavelength than red and green. This means the LED
  needs more energy to emit that color. This is why if we use the same resistance values for each color, you will notice
  that the blue will be a lot fainter than the red. I used a 1000 ohm resistor for the red and green leg (you could use
  a lower value for the green too, but I don&apos;t think it makes that much of a difference), and a 500 ohm resistor for the
  blue leg.&lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;I wired everything up in the same breadboard I used in the &lt;a href=&quot;/phys_s12_blog/2023/07/17/week6.html&quot;
    target=&quot;_blank&quot; class=&quot;link&quot;&gt;previous assignment&lt;/a&gt; to be able to combine the MPU6050 and the RGB LED to make
  something
  interesting, but we&apos;ll get to that in a bit. After everything was wired, I set the pin where the RED leg was
  connected HIGH to see if it was working:&lt;/p&gt;
&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/RGBledWired.png&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;As you can see, the LED is working as expected. I then decided to try to make it change colors using
  3 loops. The program goes through each possible value for blue (0-255), and then increments the green by one and does
  the blue loop all over again. When the green reaches 256, it goes back to 0 and red increases by one, starting the
  whole loop again. This technically goes through each possible color, but what I did not think about is the amount of
  possible colors we can &quot;make&quot; using an RGB light. Each channel (red, green, blue) can go from 0 to 255, so each has
  256 possible values, if we do the math, it turns out that the total amount of combination equals 255^3 which is equal
  to 16,777,216. If we stayed in one color for 10 miliseconds before switching to the next one, it would take us 0.001 *
  16777216 = 167772.16 seconds, or 46.6 hours to see every color. I do not intend to stare a tiny RGB Led for nearly 2
  days with no breaks, so I was going to have to do something different.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;I found some code online which had an array of &quot;key&quot; rainbow colors, so I modified for it to work with
  my setup and ran it:&lt;/p&gt;

&lt;img class=&quot;w-[50%]&quot; src=&quot;/phys_s12_blog/assets/images/rgbtest.gif&quot;&gt;
&lt;p class=&quot;mb-p italic text-right w-[50%] text-base&quot;&gt;Sped up video&lt;/p&gt;


&lt;pre class=&quot;prettyprint code mb-p&quot;&gt;
#define redpin 4
#define greenpin 5
#define bluepin 6

const uint8_t lights[360] = {
  0, 0, 0, 0, 0, 1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 17, 18, 20, 22, 24, 26, 28, 30, 
  32, 35, 37, 39, 42, 44, 47, 49, 52, 55, 58, 60, 63, 66, 69, 72, 75, 78, 81, 85, 88, 91, 94, 97, 
  101, 104, 107, 111, 114, 117, 121, 124, 127, 131, 134, 137, 141, 144, 147, 150, 154, 157, 160, 
  163, 167, 170, 173, 176, 179, 182, 185, 188, 191, 194, 197, 200, 202, 205, 208, 210, 213, 215, 
  217, 220, 222, 224, 226, 229, 231, 232, 234, 236, 238, 239, 241, 242, 244, 245, 246, 248, 249, 
  250, 251, 251, 252, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255, 254, 254, 253, 253, 
  252, 251, 251, 250, 249, 248, 246, 245, 244, 242, 241, 239, 238, 236, 234, 232, 231, 229, 226, 
  224, 222, 220, 217, 215, 213, 210, 208, 205, 202, 200, 197, 194, 191, 188, 185, 182, 179, 176, 
  173, 170, 167, 163, 160, 157, 154, 150, 147, 144, 141, 137, 134, 131, 127, 124, 121, 117, 114, 
  111, 107, 104, 101, 97, 94, 91, 88, 85, 81, 78, 75, 72, 69, 66, 63, 60, 58, 55, 52, 49, 47, 44, 
  42, 39, 37, 35, 32, 30, 28, 26, 24, 22, 20, 18, 17, 15, 13, 12, 11, 9, 8, 7, 6, 5, 4, 3, 2, 2, 
  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

int loopdelay = 100;
int displaylength = 40;

void setup() {
}

void loop() {
  for (int k = 0; k &lt; 360; k++) {
    analogWrite(redpin, lights[(k + 120) % 360]);
    analogWrite(greenpin, lights[k]);
    analogWrite(bluepin, lights[(k + 240) % 360]);
    delay(displaylength);
  }
  delay(loopdelay);
}
&lt;/pre&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Combining input and output&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;After playing around with the LED, I decided to use it to make something that is actually useful. I had
  the MPU6050 already wired, so I fixed upon an inclinometer, or tilt sensor. My idea was to make a device that turns
  green when is on a 0 degree angle (parallel to the floor), yellow when in a small angle, and red when very far from
  perfect. I had wired the input and output devices in the same breadboard, so all that was left to do was the
  software-side of the device. &lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;I started by making a class to control the rgb led, and then used the code from the last post to get the
  angle. Here is the full program:&lt;/p&gt;

&lt;pre class=&quot;prettyprint code mb-p&quot;&gt;
#include &quot;Wire.h&quot;
#include &quot;MPU6050_6Axis_MotionApps20.h&quot;

class rgbLED {
private:
  byte redPin;
  byte bluePin;
  byte greenPin;

public:
  rgbLED(byte _redPin, byte _greenPin, byte _bluePin) {
    redPin = _redPin;
    bluePin = _bluePin;
    greenPin = _greenPin;
  }

  void color(int red, int green, int blue) {
    analogWrite(redPin, red);
    analogWrite(greenPin, green);
    analogWrite(bluePin, blue);
  }
};

MPU6050 mpu;

#define INTERRUPT_PIN 18
#define I2C_SDA_PIN 16
#define I2C_SCL_PIN 17

rgbLED led(4, 5, 6);

bool dmpReady = false;   // set true if DMP init was successful
uint8_t mpuIntStatus;    // holds actual interrupt status byte from MPU
uint8_t devStatus;       // return status after each device operation (0 = success, !0 = error)
uint16_t packetSize;     // expected DMP packet size (default is 42 bytes)
uint16_t fifoCount;      // count of all bytes currently in FIFO
uint8_t fifoBuffer[64];  // FIFO storage buffer

Quaternion q;         // [w, x, y, z]         quaternion container
VectorFloat gravity;  // [x, y, z]            gravity vector
float ypr[3];         // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector

volatile bool mpuInterrupt = false;  // indicates whether MPU interrupt pin has gone high
void dmpDataReady() {
  mpuInterrupt = true;
}

void setup() {
  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  Wire.setClock(400000);
  Serial.begin(115200);

  // initialize device
  Serial.println(F(&quot;Initializing I2C devices...&quot;));
  mpu.initialize();
  pinMode(INTERRUPT_PIN, INPUT);

  // verify connection
  Serial.println(F(&quot;Testing device connections...&quot;));
  Serial.println(mpu.testConnection() ? F(&quot;MPU6050 connection successful&quot;) : F(&quot;MPU6050 connection failed&quot;));

  // load and configure the DMP
  Serial.println(F(&quot;Initializing DMP...&quot;));
  devStatus = mpu.dmpInitialize();

  if (devStatus == 0) {
    mpu.CalibrateAccel(15);
    mpu.CalibrateGyro(15);
    mpu.PrintActiveOffsets();

    Serial.println(F(&quot;Enabling DMP...&quot;));
    mpu.setDMPEnabled(true);

    // enable  interrupt detection
    Serial.print(F(&quot;Enabling interrupt detection (external interrupt &quot;));
    Serial.print(digitalPinToInterrupt(INTERRUPT_PIN));
    Serial.println(F(&quot;)...&quot;));
    attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), dmpDataReady, RISING);
    mpuIntStatus = mpu.getIntStatus();
    dmpReady = true;

    // get expected DMP packet size for later comparison
    packetSize = mpu.dmpGetFIFOPacketSize();
  } else {
    // ERROR!
    Serial.print(F(&quot;DMP Initialization failed (code &quot;));
    Serial.print(devStatus);
    Serial.println(F(&quot;)&quot;));
  }
}

float yaw = 0;
float pitch = 0;
float sum = 0;

void loop() {
  if (!dmpReady) return; // Return if MPU6050 isn&apos;t ready

  // read a packet from FIFO
  if (mpu.dmpGetCurrentFIFOPacket(fifoBuffer)) {  // Get the Latest packet
    mpu.dmpGetQuaternion(&amp;q, fifoBuffer);
    mpu.dmpGetGravity(&amp;gravity, &amp;q);
    mpu.dmpGetYawPitchRoll(ypr, &amp;q, &amp;gravity);

    yaw = abs(ypr[1] * 180 / M_PI); // absolute yaw angle
    pitch = abs(ypr[2] * 180 / M_PI); // absolute pitch angle
    sum = yaw + pitch; // Total angle

    if (sum &lt; 3) { // Less than 3 degrees -&gt; Green
      led.color(0, 255, 0);
    } else if (sum &lt; 30) { // Less than 30 degrees -&gt; Yellow
      led.color(255, 165, 0);
    } else { // 30 or more degrees -&gt; Red
      led.color(255, 0, 0);
    }
  }
}
&lt;/pre&gt;

&lt;p class=&quot;mb-p&quot;&gt;If you are actually interested in the code, I think that the most interesting part is in the loop. Be
  aware that you won&apos;t find anything too complex or exciting. &lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;It turns out that the &quot;device&quot; works perfectly, and is very fun to play around with:&lt;/p&gt;

&lt;iframe width=&quot;560&quot; class=&quot;mb-p&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/XdEXAbcXugI&quot;
  title=&quot;YouTube video player&quot; frameborder=&quot;0&quot;
  allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;
  allowfullscreen&gt;&lt;/iframe&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Using an oscilloscope&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;The output from each pin that is connected to the LED (except the ground pin) should be a PWM (pulse
  width modulation) signal, as we&apos;re using a value from 0-255 to change the brightness of each color. I wanted to see
  what that signal looked like, so I connected the oscilloscope probes to the fourth leg of the LED, which corresponds
  to green. I chose that leg because it should only be turned on when the angle of the MPU6050 is less than 30 degrees,
  so I will be able to &quot;turn the signal on and off&quot; by just tilting the whole thing. &lt;/p&gt;

&lt;iframe class=&quot;mb-p&quot; width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/sFsh2BKg8Z8&quot;
  title=&quot;YouTube video player&quot; frameborder=&quot;0&quot;
  allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;
  allowfullscreen&gt;&lt;/iframe&gt;

  &lt;p class=&quot;mb-p&quot;&gt;As you can see, when the device is parallel to the table, the signal doesn&apos;t show up. However, when I turn it slighly, we can wee a pattern that corresponds to a PWM signal. We know that because it isn&apos;t HIGH or LOW, but rather changes between the two very quickly. PWM works but switching between HIGH and LOW in a very specific time domain to create a specific signal. &lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Input devices, a.k.a. sensors</title><link href="http://localhost:4000/phys_s12_blog/2023/07/17/week6.html" rel="alternate" type="text/html" title="Input devices, a.k.a. sensors" /><published>2023-07-17T00:00:00-04:00</published><updated>2023-07-17T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/07/17/week6</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/07/17/week6.html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js&quot;&gt;&lt;/script&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;MPU6050&lt;/h2&gt;

&lt;!-- https://maker.pro/arduino/tutorial/how-to-interface-arduino-and-the-mpu-6050-sensor --&gt;


&lt;p class=&quot;mb-p&quot;&gt;The MPU6050 is an IMU (Inertial measurement unit) that has a 3-axis gyroscope and a 3-axis
  accelerometer. It can measure the velocity and orientation of an object, and comes with a Digital Motion Processor
  (DMP). The DMP is an extremely useful feature which allows us to fuse the data of the gyroscopes and the
  accelerometers to compute an orientation. This can be done manually without the DMP, but it will never be as accurate,
  as this tiny computer is specifically designed to fuse them as best and as quickly as possibe using many different
  filters. This feature is pretty difficult to interface from scrath with code, but fortunately there are some libraries
  that handle the hard work for you, so you don&apos;t have to worry about the really low-level code.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;
  The pinout of the MPU6050 is pretty simple: one VCC pin that can be connected to 3.3V or 5V, one GND pin, two pins for
  I2C communication SDA and SCl (read more about this &lt;a class=&quot;link&quot;
    href=&quot;https://en.wikipedia.org/wiki/I%C2%B2C&quot;&gt;here&lt;/a&gt;), one
  interrupt pin, and then two pins that we&apos;re not gonna use for this project.
&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;
  The interrupt pin is used to tell our microcontroller that the MPU6050 has new data available, and therefore that it
  should read it. I&apos;m using an ESP32 which doesn&apos;t have default I2C pins, but your microcontroller probably
  does
  have so you should search your board online and look for a picture of the pinout, to figure out where you should
  connect the SDA and SCL pins. The same things applies for the interrupt pin. The Arduino Uno only has a few
  interrupt-capable pins, so you should make sure the one you&apos;re using works.
&lt;/p&gt;


&lt;img class=&quot;w-[50%]&quot; src=&quot;/phys_s12_blog/assets/images/mpu6050.jpg&quot;&gt;
&lt;p class=&quot;mb-p italic text-right w-[50%] text-base&quot;&gt;MPU6050 connected to an ESP32 with a breadboard&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;
  After wiring everything up, I started working on the software. I first installed a &lt;a
    href=&quot;https://github.com/ElectronicCats/mpu6050&quot; class=&quot;link&quot;&gt;library to interface with the MPU6050&lt;/a&gt;. I then used
  one of the examples to make sure it worked. I struggeled a lot trying to figure out how to change the default SDA and
  SCL pins, but evetually got it working by adding the following lines of code before initializing the mpu:
&lt;/p&gt;

&lt;pre class=&quot;code prettyprint mb-p&quot;&gt;
  Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
  Wire.setClock(400000); 
&lt;/pre&gt;

&lt;p class=&quot;mb-p&quot;&gt;I simplified the example code to only get the yaw, pitch, and roll data (read more about this in my &lt;a
    href=&quot;/phys_s12_blog/finalproject.html&quot; class=&quot;link&quot;&gt;final project&lt;/a&gt; page) from the DMP. &lt;/p&gt;

&lt;pre class=&quot;code prettyprint mb-p&quot;&gt;
  // I2C device class (I2Cdev) demonstration Arduino sketch for MPU6050 class using DMP (MotionApps v2.0)
  // 6/21/2012 by Jeff Rowberg &lt;jeff@rowberg.net&gt;
  
  #include &quot;Wire.h&quot;
  #include &quot;MPU6050_6Axis_MotionApps20.h&quot;
  
  MPU6050 mpu;
  
  #define INTERRUPT_PIN 18 // Set your interrupt pin here
  // My esp32 doesn&apos;t have default SDA and SCL pins, so I have to manually set them
  // If you are using another board like an arduino, you have to replace those pins with the default ones
  #define I2C_SDA_PIN 16 
  #define I2C_SCL_PIN 17
  
  // MPU control/status vars
  bool dmpReady = false;   // set true if DMP init was successful
  uint8_t mpuIntStatus;    // holds actual interrupt status byte from MPU
  uint8_t devStatus;       // return status after each device operation (0 = success, !0 = error)
  uint16_t packetSize;     // expected DMP packet size (default is 42 bytes)
  uint16_t fifoCount;      // count of all bytes currently in FIFO
  uint8_t fifoBuffer[64];  // FIFO storage buffer
  
  // orientation/motion vars
  Quaternion q;         // [w, x, y, z]         quaternion container
  VectorFloat gravity;  // [x, y, z]            gravity vector
  float ypr[3];         // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector
  
  // ================================================================
  // ===               INTERRUPT DETECTION ROUTINE                ===
  // ================================================================
  
  volatile bool mpuInterrupt = false;  // indicates whether MPU interrupt pin has gone high
  void dmpDataReady() {
    mpuInterrupt = true;
  }
  
  // ================================================================
  // ===                      INITIAL SETUP                       ===
  // ================================================================
  
  void setup() {
    Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
    Wire.setClock(400000); 
  
    Serial.begin(115200);
  
    // initialize device
    Serial.println(F(&quot;Initializing I2C devices...&quot;));
    mpu.initialize();
    pinMode(INTERRUPT_PIN, INPUT);
  
    // verify connection
    Serial.println(F(&quot;Testing device connections...&quot;));
    Serial.println(mpu.testConnection() ? F(&quot;MPU6050 connection successful&quot;) : F(&quot;MPU6050 connection failed&quot;));
  
    // wait for ready
    Serial.println(F(&quot;\nSend any character to begin DMP programming and demo: &quot;));
    while (Serial.available() &amp;&amp; Serial.read())
      ;  // empty buffer
    while (!Serial.available())
      ;  // wait for data
    while (Serial.available() &amp;&amp; Serial.read())
      ;  // empty buffer again
  
    // load and configure the DMP
    Serial.println(F(&quot;Initializing DMP...&quot;));
    devStatus = mpu.dmpInitialize();
  
    // make sure it worked (returns 0 if so)
    if (devStatus == 0) {
      // Calibration Time: generate offsets and calibrate our MPU6050
      mpu.CalibrateAccel(6);
      mpu.CalibrateGyro(6);
      mpu.PrintActiveOffsets();
  
      // turn on the DMP, now that it&apos;s ready
      Serial.println(F(&quot;Enabling DMP...&quot;));
      mpu.setDMPEnabled(true);
  
      // enable  interrupt detection
      Serial.print(F(&quot;Enabling interrupt detection (external interrupt &quot;));
      Serial.print(digitalPinToInterrupt(INTERRUPT_PIN));
      Serial.println(F(&quot;)...&quot;));
      attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), dmpDataReady, RISING);
      mpuIntStatus = mpu.getIntStatus();
  
      // set our DMP Ready flag so the main loop() function knows it&apos;s okay to use it
      Serial.println(F(&quot;DMP ready! Waiting for first interrupt...&quot;));
      dmpReady = true;
  
      // get expected DMP packet size for later comparison
      packetSize = mpu.dmpGetFIFOPacketSize();
    } else {
      // ERROR!
      // 1 = initial memory load failed
      // 2 = DMP configuration updates failed
      // (if it&apos;s going to break, usually the code will be 1)
      Serial.print(F(&quot;DMP Initialization failed (code &quot;));
      Serial.print(devStatus);
      Serial.println(F(&quot;)&quot;));
    }
  }
  
  
  
  // ================================================================
  // ===                    MAIN PROGRAM LOOP                     ===
  // ================================================================
  
  void loop() {
    // if programming failed, don&apos;t try to do anything
    if (!dmpReady) return;
    // read a packet from FIFO
    if (mpu.dmpGetCurrentFIFOPacket(fifoBuffer)) {  // Get the Latest packet
      mpu.dmpGetQuaternion(&amp;q, fifoBuffer);
      mpu.dmpGetGravity(&amp;gravity, &amp;q);
      mpu.dmpGetYawPitchRoll(ypr, &amp;q, &amp;gravity);
      Serial.print(ypr[0] * 180 / M_PI);
      Serial.print(&quot;,&quot;);
      Serial.print(ypr[1] * 180 / M_PI);
      Serial.print(&quot;,&quot;);
      Serial.println(ypr[2] * 180 / M_PI);
    }
  }
  
&lt;/pre&gt;

&lt;p class=&quot;mb-p&quot;&gt;
  For the code to work you just have to replace the 3 pins defined in lines 9, 12, and 13.
&lt;/p&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Code explanation&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;The setup function runs only at the begining of the program and starts the I2C communication protocol.
  It then initializes the MPU6050 with the help of the library, and then makes sure the connection is working. It then
  waits for the user to send any message through serial communication (to avoid starting calibration and setup before
  you&apos;re ready) and begins initializing DMP. Explaining exactly how DMP works is really complicated as there are not
  that many resources online, so we won&apos;t get into the details of how it works.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;After uploading the program, open the serial monitor to send the required character and then open the
  serial plotter. There, you will see something similar to this: &lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/vQImK21apNk&quot; title=&quot;YouTube video player&quot;
  frameborder=&quot;0&quot; class=&quot;w-[50%] mb-p&quot;
  allow=&quot;accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;
  allowfullscreen&gt;&lt;/iframe&gt;
&lt;p class=&quot;mb-p&quot;&gt;As you can see, when I rotate the sensor forwards and backwards, the green line goes up and down. That
  means that the green line represents pitch. The blue line is yaw, and the red line is roll. We can get this
  information by just looking at how the lines move, but that&apos;s not really what we&apos;re interested in. That is way I
  decided to search online how to simulate that data in 3D space. I found a great tutorial that explained how to get it
  to work. If you want to take a look at it just follow &lt;a
    href=&quot;https://maker.pro/arduino/tutorial/how-to-interface-arduino-and-the-mpu-6050-sensor&quot; target=&quot;_blank&quot; class=&quot;link&quot;&gt;this
    link&lt;/a&gt;. You can see the result below:&lt;/p&gt;

&lt;iframe class=&quot;mb-p w-[50%]&quot; width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube-nocookie.com/embed/DE0h8jR9NOc&quot;
  title=&quot;YouTube video player&quot; frameborder=&quot;0&quot;
  allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot;
  allowfullscreen&gt;&lt;/iframe&gt;

&lt;p class=&quot;mb-p2&quot;&gt;Overall, this is a really interesting sensor which I will definitely use in my &lt;a
    href=&quot;/phys_s12_blog/finalproject.html&quot; class=&quot;link&quot;&gt;final project&lt;/a&gt;.&lt;/p&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Making a capacitive sensor&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;Capacitive sensing is a technology that can measure capacitance, but we are going to specifically be
  using Transmit-Receive capacitive sensing (Tx-Rx for short). Tx-Rx works by charging and discharging one electrode
  (which can be copper tape, for example) and reading the voltage of another electrode (which should be pretty close to
  the other, but without touching it). The voltage on the second electrode will vary depending on the distance of the
  two electrodes, the amount of overlap, material in-between, and other factors. &lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;For my project, I decided to attach two pieces of metal tape in opposites sides of a syringe to try and
  measure the amount of water inside the syringe. After finishing the project, I realized that the results of the Tx-Rx
  would depend on the liquid inside the syringe, and that I would have to know what the liquid inside the syringe is to
  be able to measure any possible liquid, but for the sake of simpicity we will just assume that the syringe will only
  be filled with water.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;To send and measure the signals needed for Tx-Rx, I soldered two wires on the two pieces of copper tape
  and connected them to two analog-capable pins in an ESP32. &lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/syringe.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;Based on the example code provided in class, I coded a basic program that measures and stores values received from the Tx-Rx to be able to calibrate the sensor. This is a slighly modified Tx-Rx function, which can take a specified number of samples to get an accurate reading:&lt;/p&gt;

&lt;pre class=&quot;code prettyprint mb-p&quot;&gt;
  long tx_rx(int N_samples) {  
    // Function to execute rx_tx algorithm and return a value
    // that depends on coupling of two electrodes.
    // Value returned is a long integer.
    int read_high;
    int read_low;
    int diff;
    long int sum;
  
    sum = 0;
  
    for (int i = 0; i &lt; N_samples; i++) {
      digitalWrite(tx_pin, HIGH);          // Step the voltage high on conductor 1.
      read_high = analogRead(analog_pin);  // Measure response of conductor 2.
      delayMicroseconds(100);              // Delay to reach steady state.
      digitalWrite(tx_pin, LOW);           // Step the voltage to zero on conductor 1.
      read_low = analogRead(analog_pin);   // Measure response of conductor 2.
      diff = read_high - read_low;         // desired answer is the difference between high and low.
      sum += diff;                         // Sums up N_samples of these measurements.
    }
    return sum;
  }
&lt;/pre&gt;

&lt;p class=&quot;mb-p&quot;&gt;After understand how this function works, I programmed a sketch that can read commands for easy usage: if you send any numeric value, it will perform 50,000 readings and have the total sum and the amount of samples to an array of &quot;calibrationValues&quot;, which is a struct I created. We will call that command calibration. To calibrate the sensor, I filled the syringe with 1 mL of water then ran the simulation command (typing 1 on the serial monitor) 3 times, to make sure the readings are as accurate as possible. I would then repeat this for each value of the syringe (10 mL in this case) and then export the values, using the &quot;data&quot; command. Here&apos;s an actual data output from the program:&lt;/p&gt;
&lt;div class=&quot;bg-slate-400/40 p-2 w-fit&quot;&gt;
  &lt;p class=&quot;mb-p&quot;&gt;
  Value: 0 | total sum: 477263344 | total samples: 200000 | average: 2386 &lt;br&gt;
  Value: 1 | total sum: 364642896 | total samples: 150000 | average: 2430 &lt;br&gt;
  Value: 2 | total sum: 393393068 | total samples: 150000 | average: 2622 &lt;br&gt;
  Value: 3 | total sum: 422553620 | total samples: 150000 | average: 2817 &lt;br&gt;
  Value: 4 | total sum: 489632302 | total samples: 150000 | average: 3264 &lt;br&gt;
  Value: 5 | total sum: 535462058 | total samples: 150000 | average: 3569 &lt;br&gt;
  Value: 6 | total sum: 541097142 | total samples: 150000 | average: 3607 &lt;br&gt;
  Value: 7 | total sum: 583678850 | total samples: 150000 | average: 3891 &lt;br&gt;
  Value: 8 | total sum: 594854510 | total samples: 150000 | average: 3965 &lt;br&gt;
  Value: 9 | total sum: 618753080 | total samples: 150000 | average: 4124 &lt;br&gt;
  Value: 10 | total sum: 667108406 | total samples: 150000 | average: 4447
  &lt;/p&gt;
&lt;/div&gt;

&lt;p class=&quot;mb-p&quot;&gt;After getting the results, I plotted them in a Google Spreadsheet and got the equation for the line of best fit. It turned out the equation was the following:&lt;/p&gt;

&lt;img class=&quot;w-[75%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/capacitivedata.png&quot;&gt;

&lt;img class=&quot;w-[30%] inline-block&quot; src=&quot;/phys_s12_blog/assets/images/capacitivemath.png&quot;&gt;
&lt;p class=&quot;mb-p italic text-left ml-[2.5%] inline-block w-[30%] text-base&quot;&gt;Using this equation we can guess the amount of water in mL for any give Tx-Rx output.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;I finally added a &quot;sample&quot; command to my program, which would take 3000 samples of the syringe and try to guess the amount of water inside. First using calculating the closest point based on the array of data we measured earlier and then using the equation. The full code can be found below:&lt;/p&gt;

&lt;pre class=&quot;prettyprint code mb-p&quot;&gt;
#define analog_pin 15
#define tx_pin 16

long result;  //variable for the result of the tx_rx measurement.

void setup() {
  pinMode(tx_pin, OUTPUT);  //tx-rx pin provides the voltage step
  Serial.begin(9600);
}

struct calibrationValues {
  uint8_t mlValue;
  long sum;
  long samples;
};

calibrationValues vals[] = {
  { 0, 0, 0 },
  { 1, 0, 0 },
  { 2, 0, 0 },
  { 3, 0, 0 },
  { 4, 0, 0 },
  { 5, 0, 0 },
  { 6, 0, 0 },
  { 7, 0, 0 },
  { 8, 0, 0 },
  { 9, 0, 0 },
  { 10, 0, 0 }
};

// Values after calibration with 150000 samples for each mL (0-10)
int values[] = {
  2186,
  2430,
  2622,
  2817,
  3264,
  3569,
  3607,
  3891,
  3965,
  4124,
  4447
};

void loop() {

  String content = &quot;&quot;;
  char character;

  // Wait for command through serial
  while (Serial.available()) {
    character = Serial.read();
    content.concat(character);
    delay(10);
  }

  if (content != &quot;&quot;) {
    content.trim();
    int x = content.toInt();
    if (content == &quot;data&quot;) {
      for (int i = 0; i &lt; 11; i++) {
        // Prints the CalibrationValues array
        Serial.print(&quot;Value: &quot;);
        Serial.print(i);
        Serial.print(&quot; | total sum: &quot;);
        Serial.print(vals[i].sum);
        Serial.print(&quot; | total samples: &quot;);
        Serial.print(vals[i].samples);
        Serial.print(&quot; | average: &quot;);
        Serial.println(vals[i].sum / (vals[i].samples + 1));
      }
    } else if (content == &quot;sample&quot;) {
      // Sample current status of syringe and print result
      int samples = 3000;
      result = tx_rx(samples) / samples;
      int minDistance = 0;
      for (int i = 0; i &lt; 11; i++) {
        int distance = abs(result - values[i]);
        if (distance &lt; abs(result - values[minDistance])) minDistance = i;
      }
      Serial.print(&quot;-&gt; Estimation based on distance from calibration points: &quot;);
      Serial.print(minDistance);
      Serial.println(&quot; mL&quot;);

      Serial.print(&quot;-&gt; Estimation based on line of best fit: &quot;);
      Serial.print((result-2238.0)/224.0);
      Serial.println(&quot; mL&quot;);
    } else {
      // Calibration: Samples 50000 times and adds the results to the CalibrationValues array
      int samples = 50000;
      result = tx_rx(samples);
      vals[x].sum += result;
      vals[x].samples += samples;
      Serial.print(&quot;For &quot;);
      Serial.print(x);
      Serial.print(&quot; mL : &quot;);
      Serial.println((vals[x].sum / vals[x].samples));
    }
    content = &quot;&quot;;
  }
}


long tx_rx(int N_samples) {  
  // Function to execute rx_tx algorithm and return a value
  // that depends on coupling of two electrodes.
  // Value returned is a long integer.
  int read_high;
  int read_low;
  int diff;
  long int sum;

  sum = 0;

  for (int i = 0; i &lt; N_samples; i++) {
    digitalWrite(tx_pin, HIGH);          // Step the voltage high on conductor 1.
    read_high = analogRead(analog_pin);  // Measure response of conductor 2.
    delayMicroseconds(100);              // Delay to reach steady state.
    digitalWrite(tx_pin, LOW);           // Step the voltage to zero on conductor 1.
    read_low = analogRead(analog_pin);   // Measure response of conductor 2.
    diff = read_high - read_low;         // desired answer is the difference between high and low.
    sum += diff;                         // Sums up N_samples of these measurements.
  }
  return sum;
}
&lt;/pre&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">3D Scanning and Printing, legos!</title><link href="http://localhost:4000/phys_s12_blog/2023/07/12/week5.html" rel="alternate" type="text/html" title="3D Scanning and Printing, legos!" /><published>2023-07-12T00:00:00-04:00</published><updated>2023-07-12T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/07/12/week5</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/07/12/week5.html">&lt;h2 class=&quot;text-xl underline&quot;&gt;3D Scanning&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;3D CAD can be very useful to &lt;span class=&quot;hl&quot;&gt;accurately design&lt;/span&gt; things, but trying to replicate a
  &lt;span class=&quot;hl&quot;&gt;complex real-world shape
  &lt;/span&gt; can be quite challenging. 3D scanning is a very useful technology which can create a 3D model of a physical
  model by scanning it using many different techniques. In our lab, there is a &lt;a href=&quot;www.revopoint3d.com&quot;
    class=&quot;link&quot;&gt;RevoPoint scanner&lt;/a&gt;, which is (supposedly) very accurate.
&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;The software to control the camera has a &quot;body&quot; option, so I naturally started by trying to 3D scan my
  face (who wouldn&apos;t?). &lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/3dfacescan.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;My main face traits were fairly detailed, but the camera really struggled with my hair (which makes
  sense honestly). After trying to scan my whole face multiple times, I gave up, as I was not willing to shave my hair
  to have a good result.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt; While I was looking through random things in the lab, I found a box filled with Lego pieces. Ever since
  I was a kid, I&apos;ve loved Lego. Here&apos;s a short stop-motion clip I made when I was 12 years old: &lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/stopmotion.gif&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;There was this really interesting skeleton Horse, which had a cool shape that would be really hard to
  replicate with CAD, so I decided to scan it.&lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/legohorse.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;There&apos;s a small rotating base in the lab that is really useful to scan objects, as it rotates them in a
  slow and consistent way so that the scanner can keep track of the object and at the same time get measurements from
  every side of it. It is possible to do it by hand, by moving the camera around the object, but I don&apos;t recommend it
  because the camera can very easly loose track of the object, and once that happens it&apos;s extremely hard for it to
  &quot;retrack&quot; the object. This problem happened to me more that once, and I was forced to restart the scan each time.&lt;/p&gt;

&lt;img class=&quot;w-[50%]&quot; src=&quot;/phys_s12_blog/assets/images/3dscansetup.jpg&quot;&gt;
&lt;p class=&quot;mb-p italic text-right w-[50%] text-base&quot;&gt;Picture of the setup I used to scan the lego horse&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;The result of the scan is called a &lt;span class=&quot;hl&quot;&gt;cloud point&lt;/span&gt;, which as its name implies, is a
  cloud of points, and not a 3D model. The result therefore has to be processed to be converted to a 3d mesh (.stl file
  for example). The RevoPoint software has many options to edit the result, which I used mainly to remove small floating
  meshes. But other than that, the output file is ready to use to either view it in your computer, or &lt;strong&gt;3D print
    it&lt;/strong&gt;.&lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/3dscanresult.png&quot;&gt;

&lt;iframe class=&quot;w-[75%]&quot;
  src=&quot;https://icloud83866.autodesk360.com/shares/public/SHd38bfQT1fb47330c99ad92f4327d42f0d7?mode=embed&quot; width=&quot;640&quot;
  height=&quot;480&quot; allowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;p class=&quot;mb-p italic text-right w-[75%] text-base&quot;&gt;3D Model&lt;/p&gt;


&lt;h2 class=&quot;text-xl underline&quot;&gt;3D Printing&lt;/h2&gt;

&lt;p class=&quot;&quot;&gt;The thing I was most looking forward to this week was &lt;strong&gt;3D printing&lt;/strong&gt;. This fabrication
  method is what I intend to use to build a big chunck of my final project. There are two main types manufacturing: &lt;/p&gt;
&lt;ul class=&quot;list-disc mb-p ml-[5%]&quot;&gt;
  &lt;li&gt;&lt;span class=&quot;hl&quot;&gt;Substractive manufacturing&lt;/span&gt;: raw material is cut to produce a desired shape and size&lt;/li&gt;
  &lt;li&gt;&lt;span class=&quot;hl&quot;&gt;Additive manufacturing&lt;/span&gt;: material is joined/deposited/solidified by (generally) a machine
    layer by layer, such as 3D printers&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;mb-p&quot;&gt;The lab has quite a few Prusa MK3 printers,
  which are very capable and can print medium-sized objects. Although they are not very fast, the result is definitely
  worth the waiting. The worflow to use them is as easy as exporting a 3D model as a mesh, &quot;&lt;span
    class=&quot;hl&quot;&gt;slicing&lt;/span&gt;&quot; it with the help of a slicing software (such as &lt;a
    href=&quot;https://www.prusa3d.com/page/prusaslicer_424/&quot; class=&quot;link&quot;&gt;Prusa Slicer&lt;/a&gt;), and sending the &lt;span
    class=&quot;hl&quot;&gt;gcode&lt;/span&gt; (set of instructions) to the printer.&lt;/p&gt;

&lt;img class=&quot;w-[50%]&quot; src=&quot;/phys_s12_blog/assets/images/3dexport.png&quot;&gt;
&lt;p class=&quot;mb-p italic text-right w-[50%] text-base&quot;&gt;Exporting the 3D model as a mesh to the slicer&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;The slicer&apos;s job is to generate a file containing all the places the printer has to go, based on your 3D
  mesh. It therefore needs to know exactly what printer you&apos;re using, what material (PLA in my case), and a lot of other
  things.&lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;Some objects have big slopes that impossible to print, because it&apos;s not possible to print in mid-air.
  That is what &lt;span class=&quot;hl&quot;&gt;supports&lt;/span&gt; are for. They provide a surface for the printer to put material, and
  then are easly removable once the print is done (or at least they are supposed to be...). &lt;/p&gt;

&lt;img class=&quot;w-[45%] mr-[2.5%] inline-block&quot; src=&quot;/phys_s12_blog/assets/images/slicing.gif&quot;&gt;
&lt;img class=&quot;w-[45%] inline-block&quot; src=&quot;/phys_s12_blog/assets/images/slicingsupports.gif&quot;&gt;
&lt;p class=&quot;mb-p inline-block italic text-right w-[45%] mr-[2.5%] text-base&quot;&gt;Slicer with no supports enabled&lt;/p&gt;
&lt;p class=&quot;mb-p inline-block italic text-right w-[45%] text-base&quot;&gt;Slicer with default supports enabled&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;The slicer also tells you how long the print will take, and how much material it will use. You can find
  the time required for this print in the image below. &lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/slicertimes.png&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;The next day I went to the lab to see the result, and found myself with a black plastic brick. &lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/finishedprint.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;The support was &lt;strong&gt;extremely&lt;/strong&gt; hard to remove. It took me more than one hour with the
  help of a small screw driver to get rid of it. It was so difficult to remove the support, and I had to do so much
  force, that two of the breaks of the horse unfortunatly broke. This first print served me as a lesson to &lt;span
    class=&quot;hl&quot;&gt;always test different orientations when slicing&lt;/span&gt; the model, as I could&apos;ve probably used a lot let
  supports if I had printed it side-ways, intead of upright. Nevertheless, the result was actually much better than I
  expected, but of course had some errors.&lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/horseresult.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;I am definitely very happy with the results, but most I importantly learned a lot of useful and
  interesting things, which I am sure will use in my final project.&lt;/p&gt;

&lt;p class=&quot;text-xl&quot;&gt;Click here to download the &lt;a class=&quot;link&quot;
    href=&quot;/phys_s12_blog/assets/stl/skeletonHorse.stl&quot;&gt;.stl file&lt;/a&gt; and the &lt;a
    href=&quot;/phys_s12_blog/assets/stl/Horse_0.2mm_PLA_MK3S_5h5m.gcode&quot; class=&quot;link&quot;&gt;.gcode file&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">3D Scanning</summary></entry><entry><title type="html">Electronics and Tools&amp;lt;/br&amp;gt;(or how to build a Mini-Fountain)</title><link href="http://localhost:4000/phys_s12_blog/2023/07/05/week3.html" rel="alternate" type="text/html" title="Electronics and Tools&amp;lt;/br&amp;gt;(or how to build a Mini-Fountain)" /><published>2023-07-05T00:00:00-04:00</published><updated>2023-07-05T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/07/05/week3</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/07/05/week3.html">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js&quot;&gt;&lt;/script&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Idea and objectives&lt;/h2&gt;
&lt;p class=&quot;mb-p&quot;&gt;This week we learned about &lt;strong&gt;Motors&lt;/strong&gt;, &lt;strong&gt;Electronics&lt;/strong&gt;, and
  &lt;strong&gt;Microcontrollers&lt;/strong&gt;. To create something using all of those new concepts, I decided to create a water
  fountain. I knew from the begining it wasn&apos;t going to be an easy task, but I encountered a lot more problems than I
  initially expected.
&lt;/p&gt;

&lt;p class=&quot;font-bold&quot;&gt;The main challenges of this project are: &lt;/p&gt;
&lt;ul class=&quot;ml-[5%] mb-p list-disc&quot;&gt;
  &lt;li&gt;Fabricating a watertight container&lt;/li&gt;
  &lt;li&gt;Controlling and using a water pump&lt;/li&gt;
  &lt;li&gt;Ataching the different parts of the project (water container, pump, electronics, etc)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;mb-p&quot;&gt;I started by drawing some sketches. I drew a boat-like shape, and a small structure on top of it which
  holds a small water pump (which I had found in the lab last week). I added some dimensions to have an idea of how the
  thing would actually look, and then modeled it with Fusion360.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/fountainsketch.jpg&quot; class=&quot;inline-block mr-[2.5%] mb-p w-[45%]&quot;&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/fountaincad.png&quot; class=&quot;inline-block w-[45%]&quot;&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/fountaincad.gif&quot; class=&quot;w-[50%] mx-auto&quot;&gt;

&lt;p class=&quot;w-[50%] mx-auto hl text-center mb-p&quot;&gt;Click to download the &lt;a class=&quot;link&quot;
    href=&quot;/phys_s12_blog/assets/stl/MiniFountain.f3d&quot;&gt;.f3d File&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;The main idea is to have an &lt;span class=&quot;hl&quot;&gt;acrylic base&lt;/span&gt; (with a boat-like shape) that can serve
  as a water container. A secondary &lt;span class=&quot;hl&quot;&gt;smaller base&lt;/span&gt; would hold a &lt;span class=&quot;hl&quot;&gt;water pump&lt;/span&gt;
  in place, along with all the required electronics (&lt;span class=&quot;hl&quot;&gt;esp32, batteries, motor driver&lt;/span&gt;). The two
  bases will be attached with &lt;span class=&quot;hl&quot;&gt;two aluminum rods&lt;/span&gt; and &lt;span class=&quot;hl&quot;&gt;M6 screws&lt;/span&gt; (more on
  that later). &lt;/p&gt;
&lt;iframe class=&quot;mb-p2&quot;
  src=&quot;https://icloud83866.autodesk360.com/shares/public/SHd38bfQT1fb47330c994103620c2994fc57?mode=embed&quot; width=&quot;640&quot;
  height=&quot;480&quot; allowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;h2 class=&quot;text-xl mt-[30px] underline&quot;&gt;Prototyping&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;After finishing the CAD model, I laser-cutted the whole thing with cardboard to make sure everything
  would fit correctly, as I didn&apos;t want to waste acrylic. It was important to test if the water pump holder fitted, if
  the container dimension&apos;s were decent, and have a rough idea of how the fountain would look in real life. &lt;/p&gt;
&lt;img class=&quot;w-[45%] inline-block mb-p mr-[2.5%]&quot; src=&quot;/phys_s12_blog/assets/images/fountainprotopieces.jpg&quot;&gt;
&lt;img class=&quot;w-[45%] inline-block mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainprotoholder.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;I then decided to use a highly advanced chemical compound to join all the pieces together: &lt;span
    class=&quot;hl&quot;&gt;hot glue&lt;/span&gt;.&lt;/p&gt;
&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainproto.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;The next step was to join the two &quot;bases&quot;. As I said earlier, we are going to use aluminum rods. The
  problem is that the lab only had very long aluminum rods. I therefore had to cut one in half to create two smaller
  ones using a hand saw.&lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainrods.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;The next challenge was to figure out how to attach the rods to the top-base (which holds the water pump
  and the electronics). Last week we were taught how to thread the inside of a hole, and the rods I&apos;m using happen to be
  hollow, so I used a M6 screw drill tip to thread the end of each aluminum rod. Finding a fitting screw was quite a
  challenge, and I ended up switching to the imperial system to find an appropiate screw (I basically went through every
  single screw in the lab to find the right one).&lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainbaserods.jpg&quot;&gt;

&lt;h2 class=&quot;text-xl mt-[30px] underline&quot;&gt;Final build&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;I laser-cutted the structure in acrylic, clamped it together, and glued it with epoxy. After waiting
  approximately 30 minutes, I glued the &quot;ramp&quot; to the rest of the structure, which was impossible to do before the rest
  of the structure was glued together.&lt;/p&gt;

&lt;img class=&quot;w-[50%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainclamps.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;After assembling everything, I realized that due to a pretty low contact surface, it was not going to be
  possible to glue the two aluminum rods to the base using epoxy. This is the kind of thing that I should&apos;ve planned
  beforehand, but because my lack of experience, didn&apos;t think of. I ultimately decided to drill two holes through the
  base of the fountain (which was extremly hard to do, mainly because of clamping issues) and attach the rods using
  screws. After threading the inside of the rods again, which was a really tedious task, I was finally able to attach
  the rods. All in all, this problem was a big setback with delayed the project more than I expected. &lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;The next step is to assemble all the electronics. &lt;span class=&quot;hl&quot;&gt;3 AA batteries&lt;/span&gt; are connected
  to the 5V (4.5V in total, 1.5V each battery) and GND pins of an &lt;span class=&quot;hl&quot;&gt;ESP32&lt;/span&gt;, aswell as the VCC and
  GND pins of a motor driver (I used the &lt;span class=&quot;hl&quot;&gt;L9110&lt;/span&gt;). The ESP32 is connected to the A-IA pin of the
  motor driver (&lt;span class=&quot;hl&quot;&gt;make sure the esp32 pin supports PWM, I used pin 12&lt;/span&gt;), which controls the speed
  of the motor. The motor driver is then connected to the water pump using two terminals and the wires that come with
  the motor. To easly manage power, I used solder to add two extra outputs to the batteries. This was necessary because
  as we just discussed, &lt;strong&gt;two&lt;/strong&gt; components need both VCC and GND inputs. To keep things simple (and mainly
  due to a lack of time), I zip tied all the components. Before assembling the components, I quickly threw together a
  schematic in Eagle (fusion360) to have an idea of what the electronics would roughly look like (see image below).&lt;/p&gt;

&lt;img class=&quot;inline-block w-[45%] mr-[2.5%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainschematic.png&quot;&gt;
&lt;img class=&quot;inline-block w-[45%] mb-p&quot; src=&quot;/phys_s12_blog/assets/images/fountainelectronics.jpg&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;The final thing we need to do to have a working fountain, is to program our microcontroller. I will use
  the arduino programming language. I wrote a simple program that varies the speed of the pump over time using a sine
  wave, and uploaded it to the esp32 to finally test the water fountain. &lt;/p&gt;

&lt;pre class=&quot;code prettyprint&quot;&gt;

#define A1A 12  // pin 12 is defined for A1A, which controls the speed of the motor

void setup() {
  pinMode(A1A, OUTPUT);
}

void loop() {
  runMotor(A1A, 180, 255);
  delay(1);
}

// Variables for calculations regarding motor speed
float value;
float interpolatedValue;

// Function that drives motor with a speed interpolated from &apos;min&apos; to &apos;max&apos; using a sine wave
// Inputs: pin, minimumSpeed (0-255), maximumSpeed (0-255)
void runMotor(int pin, int min, int max) {
  value = sin(millis() / 1000.0);
  interpolatedValue = map(abs(value * 100), 0, 100, min, max);
  analogWrite(pin, 255 - interpolatedValue);
}

&lt;/pre&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">3D Modeling Household Objects</title><link href="http://localhost:4000/phys_s12_blog/2023/06/26/week25.html" rel="alternate" type="text/html" title="3D Modeling Household Objects" /><published>2023-06-26T00:00:00-04:00</published><updated>2023-06-26T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/06/26/week25</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/06/26/week25.html">&lt;h2 class=&quot;text-xl underline&quot;&gt;&lt;strong&gt;1)&lt;/strong&gt; Modeling a lamp&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;The first household object I decided to model was a lamp. My goal is to succesfully model a good-looking
    lamp without using any tutorials, and therefore test my 3D modeling skills.&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;I started modeling the base, which I made with 2 circles (one with a fixed diameter of &lt;span
        class=&quot;hl&quot;&gt;120 mm&lt;/span&gt;, and the other with a fixed offset of &lt;span class=&quot;hl&quot;&gt;-12.5 mm&lt;/span&gt;). I also added a
    smaller circle off-center, which is where the arm of the lamp will come out of.&lt;/p&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step1.png&quot; class=&quot;mb-p w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;I then extruded the outer circle &lt;span class=&quot;hl&quot;&gt;30 mm&lt;/span&gt; and the inner circle (without the
    off-centered circle) &lt;span class=&quot;hl&quot;&gt;20 mm&lt;/span&gt;. To make it look better, I used a fillet with a &lt;span
        class=&quot;hl&quot;&gt;rolling ball corner type&lt;/span&gt;. &lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step2.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p italic&quot;&gt;&lt;span class=&quot;font-bold&quot;&gt;Side note: &lt;/span&gt; Adding appearances to 3D models can make them look a
    lot better (even if it&apos;s just a visual thing, it can make modeling much more pleasing). You will find bellow a
    picture of that same base with a wood appearance, and you&apos;ll notice that it looks a lot better.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step2wood.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;


&lt;p class=&quot;mb-p&quot;&gt;I then started to work on the arm. I started by sketching a &lt;span class=&quot;hl&quot;&gt;path&lt;/span&gt;, which will be
    followed by a &lt;span class=&quot;hl&quot;&gt;profile&lt;/span&gt; (a circle in this case) to create the 3D arm. I created the path using
    the &lt;span class=&quot;hl&quot;&gt;spline tool&lt;/span&gt; and eyeballing the general shape (it&apos;s really hard to measure curved
    objects, and I never intended to have an exact replica of my lamp).&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step3.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;After finishing the path, I used the &lt;span class=&quot;hl&quot;&gt;sweep tool&lt;/span&gt; to generate a 3D model of the
    path using the off-cetered hole we sketched earlier as a profile.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step4.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;The next step was undoubtedly the hardest part of the modeling process: the lampshade. I knew I wanted
    to do some kind of triangle, but I didn&apos;t know where to start. After taking a look at the different tools Fusion
    has, I decided to use the &lt;splan class=&quot;hl&quot;&gt;revolve tool&lt;/splan&gt;. The revolve tool replicates a profile along an
    axis, which is exactly what I needed. I first created a point in the center of the end-part of the arm and created a
    perpendicular axis between that point and the arm (see image below, it&apos;s pretty hard to explain!). &lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step5.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;Using that axis, I created a plane which I used to create a sketch. The sketch is essentially a straight
    line with a &lt;span class=&quot;hl&quot;&gt;75 degree angle&lt;/span&gt; and a length of &lt;span class=&quot;hl&quot;&gt;70 mm&lt;/span&gt;. &lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/step6.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;Finally, I used the revolve tool to replicate that sketch along the axis we created earlier. I used a
    &lt;span class=&quot;hl&quot;&gt;360 degree angle&lt;/span&gt; to make a full circle, and therefore have a closed lampshade. &lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lampModel/finished.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;text-lg mb-[5%]&quot;&gt;If you want to take a look at the design, you can download the &lt;a
        href=&quot;/phys_s12_blog/assets/stl/lamp-stl.stl&quot; class=&quot;link&quot;&gt;.stl file&lt;/a&gt; or the Fusion360 &lt;a
        href=&quot;/phys_s12_blog/assets/stl/lamp-f3d.f3d&quot; class=&quot;link&quot;&gt;.f3d file&lt;/a&gt;, or you can interact with it
    below!&lt;/p&gt;

&lt;iframe src=&quot;https://icloud83866.autodesk360.com/shares/public/SHd38bfQT1fb47330c99418829d72994de6f?mode=embed&quot;
    width=&quot;800&quot; height=&quot;600&quot; allowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot;
    frameborder=&quot;0&quot; class=&quot;mb-p2&quot;&gt;&lt;/iframe&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;&lt;strong&gt;2)&lt;/strong&gt; Modeling a pencil sharpener&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;The second object I&apos;m going to model is a pencil sharpener. This time, I will try to replicate my real
    pencil sharpener as accurately as possible. That is why I&apos;m going to use a caliper, which I strongly encourage
    anyone who wants to accurately model something to use.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/caliper.jpg&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;After taking a few measurements (you will find the measurements bellow) I sketched a simple top-down
    view of the sharpener.&lt;/p&gt;

&lt;div class=&quot;mb-p2&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement1.jpg&quot;
        class=&quot;inline-block mr-[3%] mb-[1%] w-[25%]&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement2.jpg&quot;
        class=&quot;inline-block mr-[3%] mb-[1%] w-[25%]&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement3.jpg&quot; class=&quot;inline-block mb-[1%] w-[25%]&quot;&gt;
    &lt;p class=&quot;inline-block text-center mr-[3%] w-[25%] hl&quot;&gt;32.5 mm&lt;/p&gt;
    &lt;p class=&quot;inline-block text-center mr-[3%] w-[25%] hl&quot;&gt;37.6 mm&lt;/p&gt;
    &lt;p class=&quot;inline-block text-center w-[25%] hl&quot;&gt;39.1 mm&lt;/p&gt;
&lt;/div&gt;



&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/topdownsketch.png&quot; class=&quot;w-[35%]&quot;&gt;
&lt;p class=&quot;mb-p italic text-right w-[35%]&quot;&gt;Top-down sketch&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;I then did the same thing from a side-view. &lt;/p&gt;

&lt;div class=&quot;mb-p2&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement4.jpg&quot;
        class=&quot;inline-block mr-[3%] mb-[1%] w-[35%]&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement5.jpg&quot;
        class=&quot;inline-block mr-[3%] mb-[1%] w-[35%]&quot;&gt;
    &lt;p class=&quot;inline-block text-center mr-[3%] w-[35%] hl&quot;&gt;21.47 mm  21.5 mm&lt;/p&gt;
    &lt;p class=&quot;inline-block text-center mr-[3%] w-[35%] hl&quot;&gt;25.69 mm  25.7 mm&lt;/p&gt;
&lt;/div&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/sidesketch.png&quot; class=&quot; inline-block w-[45%] mr-[5%]&quot;&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/step1.png&quot; class=&quot;inline-block w-[45%]&quot;&gt;

&lt;p class=&quot;mb-p italic text-right w-[43%]&quot;&gt;Side sketch&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;Now that we have this basic sketch, we can begin to create more detailed lines in the two different
    sketches and then extrude them to create a 3D model.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/modelingvideo.gif&quot; class=&quot;mb-p w-[75%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;We can then join the two ellipses we just created using the &lt;span class=&quot;hl&quot;&gt;loft tool&lt;/span&gt;, which
    &lt;span class=&quot;italic&quot;&gt;&quot;creates a transitional shape shape between two or more sketch profiles or planar faces&quot;.
    &lt;/span&gt;&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/step2.png&quot; class=&quot;mb-p w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;I then went back to the back-side sketch and added two circles with the dimensions I got using the
    caliper&lt;/p&gt;

&lt;div class=&quot;mb-p&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement6.jpg&quot;
        class=&quot;inline-block mr-[3%] mb-[1%] w-[35%]&quot;&gt;
    &lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/measurement7.jpg&quot;
        class=&quot;inline-block mr-[3%] mb-[1%] w-[35%]&quot;&gt;
    &lt;p class=&quot;inline-block text-center mr-[3%] w-[35%] hl&quot;&gt;11.34 mm  11.3 mm&lt;/p&gt;
    &lt;p class=&quot;inline-block text-center mr-[3%] w-[35%] hl&quot;&gt;8.1 mm&lt;/p&gt;
&lt;/div&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/step3.png&quot; class=&quot;mb-p w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;To create the hole, I started by creating an offset plane from those two circles with a distance of
    &lt;span class=&quot;hl&quot;&gt;15 mm&lt;/span&gt;. I created a sketch on that plane, projected the two circles we just created, and then
    created two new circles with an offset of &lt;span class=&quot;hl&quot;&gt;-4 mm&lt;/span&gt; for the big circle and &lt;span class=&quot;hl&quot;&gt;-2.5
        mm&lt;/span&gt; for the smaller one. We can now use the same tool we used before, loft, to reproduce the same effect
    we used earlier, but this time to cut into our existing model.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/step4.png&quot; class=&quot;mb-p w-[50%]&quot;&gt;

&lt;p class=&quot;mb-p&quot;&gt;To make it look better, I used the &lt;span class=&quot;hl&quot;&gt;fillet tool&lt;/span&gt; to round the edges and added a
    black material to the model. We could add even more detail to the ouside of the pencil sharpener (some lines and
    depth) but I don&apos;t think it is worth, given that we would re-use the tools used in this model and the previous one.
    You&apos;ll find an image of the finished version bellow, along with some links to download the file in case you want to
    use/modify the model.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/sharpenerModel/finished.png&quot; class=&quot;mb-p2 w-[50%]&quot;&gt;

&lt;p class=&quot;text-lg mb-[5%]&quot;&gt;If you want to take a look at the design, you can download the &lt;a
        href=&quot;/phys_s12_blog/assets/stl/sharpener-stl.stl&quot; class=&quot;link&quot;&gt;.stl file&lt;/a&gt; or the Fusion360 &lt;a
        href=&quot;/phys_s12_blog/assets/stl/sharpener-f3d.f3d&quot; class=&quot;link&quot;&gt;.f3d file&lt;/a&gt;, or you can interact with
    it below!&lt;/p&gt;

&lt;iframe src=&quot;https://icloud83866.autodesk360.com/shares/public/SHd38bfQT1fb47330c9966d561ffb5d2eae5?mode=embed&quot;
    width=&quot;640&quot; height=&quot;480&quot; allowfullscreen=&quot;true&quot; webkitallowfullscreen=&quot;true&quot; mozallowfullscreen=&quot;true&quot;
    frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</content><author><name></name></author><summary type="html">1) Modeling a lamp</summary></entry><entry><title type="html">Laser cutting: visiting Paris with cardboard</title><link href="http://localhost:4000/phys_s12_blog/2023/06/24/week2.html" rel="alternate" type="text/html" title="Laser cutting: visiting Paris with cardboard" /><published>2023-06-24T00:00:00-04:00</published><updated>2023-06-24T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/06/24/week2</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/06/24/week2.html">&lt;h2 class=&quot;text-xl underline&quot;&gt;Concept&lt;/h2&gt;
&lt;p class=&quot;mb-p&quot;&gt;Laser cutting is an extremely useful technique to cut simple materials, such as cardboard. This week, we
    learned how to operate a laser cutter and were assigned to create a press-fit construction. To accomplish this, I
    decided to use a CAD software called Fusion360. I already had experience using it, and the only way to do parametric
    accurate modeling in the other software option, Blender, is by using the addon &lt;a class=&quot;link&quot;
        href=&quot;https://www.cadsketcher.com/&quot;&gt;CAD Sketcher&lt;/a&gt;. CAD Sketcher is an extremely new tool, and while it is
    true it has a huge community supporting it, I don&apos;t think that it has enough features to be used in big projects.
&lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;After choosing which software I was going to use, I modeled some simple press-fit squares to know how
    much material the laser burns when cutting through cardboard. This is called laser kerf. I found out that a good
    value for the laser kerf was &lt;span class=&quot;hl&quot;&gt;0.8 mm&lt;/span&gt;, which is less than I expected it to be. This meant I
    had to make my press-fit joints smaller than I initially thought.&lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/pressfittest.jpg&quot; class=&quot;mb-[1%] inline-block max-h-[432px] w-[49%]&quot;
    alt=&quot;Picture of two press-fit cardboard squares&quot;&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/pressfittestmodel.png&quot; class=&quot;w-[49%] align-top inline-block&quot;&gt;
&lt;p class=&quot;w-fit hl mb-p&quot;&gt;Click to download the &lt;a class=&quot;link&quot;
        href=&quot;/phys_s12_blog/assets/stl/press-fit-stl.stl&quot;&gt;.STL File&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;As you can probably see in the joints, the cardboard is slightly bent, and I had to do some force to get
    them to fit together. While that can be good for long-lasting designs, it is not what I&apos;m looking for. After
    disassembling and assembling it a few times, the cardboard would probably break. &lt;/p&gt;
&lt;p&gt;Later on, I started thinking about what kind of press-fit &quot;structure&quot; I was going to create. At first, I thought
    about doing something like a puzzle, but then I decided to go for something much more unique: the Eiffel Tower. I
    looked up some sketches online and decided to start modeling.&lt;/p&gt;

&lt;h2 class=&quot;text-xl mt-[30px] underline&quot;&gt;Modeling&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;The first thing I did was to search online for a reference image. I don&apos;t intend the model to be
    identical to the real Eiffel Tower, but I do expect it to look alike.&lt;/p&gt;

&lt;a target=&quot;_blank&quot; href=&quot;https://www.wikihow.com/Draw-the-Eiffel-Tower&quot;&gt;&lt;img class=&quot;inline-block w-[50%] mb-p&quot;
        src=&quot;/phys_s12_blog/assets/images/eiffeltowersketch.jpg&quot;&gt;&lt;/a&gt;

&lt;p class=&quot;mb-p&quot;&gt;I then began to think about how I could join the different parts of the structure. The best idea I came
    up with was to cut 4 separate &quot;legs&quot;, and then join all four of them using press-fit squares placed in between them.
    I used splines to model the legs, which made designing them really easy. You can see the layout of the design below.
&lt;/p&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/eiffeltowerlayout.png&quot; class=&quot;w-[50%] mb-p&quot;&gt;
&lt;p class=&quot;w-fit hl mb-p2&quot;&gt;Click to download the &lt;a class=&quot;link&quot;
        href=&quot;/phys_s12_blog/assets/stl/eiffel-tower-stl.stl&quot;&gt;.STL File&lt;/a&gt;&lt;/p&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Laser Cutting&lt;/h2&gt;

&lt;p class=&quot;mb-p&quot;&gt;After finishing the design, I exported the sketch as a &lt;span class=&quot;hl&quot;&gt;.dxf&lt;/span&gt; file and loaded it
    into the laser cutter&apos;s computer using an SD card. The next step was to send it to the actual laser cutter, and then
    finally, chose the point in space where it should start cutting (to avoid cutting outside the cardboard, which would
    be a pretty bad thing!). &lt;/p&gt;

&lt;img src=&quot;/phys_s12_blog/assets/images/lasercutter.jpg&quot; class=&quot;w-[50%]&quot; alt=&quot;Picture of the laser cutting&quot;&gt;
&lt;p class=&quot;mb-p italic text-right w-[50%]&quot;&gt;Picture of the laser cutter&lt;/p&gt;

&lt;p class=&quot;mb-p&quot;&gt;The moment I got the pieces out of the laser cutter, I realized that I should have made the design
    bigger. I designed the model to be &lt;span class=&quot;hl&quot;&gt;22 cm&lt;/span&gt; tall, which I thought would be a good height, but I
    quickly realized that having small values means having tiny amounts of material near the joints. The joints are
    therefore quite fragile. Nevertheless, everything fitted perfectly and the design turned out exactly like I wanted
    it to be.&lt;/p&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/eiffeltowerfinished.jpg&quot; class=&quot;w-[30%]&quot;&gt;
&lt;p class=&quot;mb-p2 italic text-right w-[30%]&quot;&gt;Finished Eiffel Tower&lt;/p&gt;

&lt;h2 class=&quot;text-xl underline&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;By working on this project, I learned how to use a laser cutter, deepened my CAD skills, and &lt;span class=&quot;hl&quot;&gt;visited
        Paris&lt;/span&gt;! Next time, I will make larger designs and make sure there is enough material near the joints so
    the structure can be as strong as possible.&lt;/p&gt;</content><author><name></name></author><summary type="html">Concept Laser cutting is an extremely useful technique to cut simple materials, such as cardboard. This week, we learned how to operate a laser cutter and were assigned to create a press-fit construction. To accomplish this, I decided to use a CAD software called Fusion360. I already had experience using it, and the only way to do parametric accurate modeling in the other software option, Blender, is by using the addon CAD Sketcher. CAD Sketcher is an extremely new tool, and while it is true it has a huge community supporting it, I don&apos;t think that it has enough features to be used in big projects. After choosing which software I was going to use, I modeled some simple press-fit squares to know how much material the laser burns when cutting through cardboard. This is called laser kerf. I found out that a good value for the laser kerf was 0.8 mm, which is less than I expected it to be. This meant I had to make my press-fit joints smaller than I initially thought.</summary></entry><entry><title type="html">Website creation and final project ideas</title><link href="http://localhost:4000/phys_s12_blog/2023/06/21/week1.html" rel="alternate" type="text/html" title="Website creation and final project ideas" /><published>2023-06-21T00:00:00-04:00</published><updated>2023-06-21T00:00:00-04:00</updated><id>http://localhost:4000/phys_s12_blog/2023/06/21/week1</id><content type="html" xml:base="http://localhost:4000/phys_s12_blog/2023/06/21/week1.html">&lt;h2 class=&quot;text-xl underline&quot;&gt;Website technology&lt;/h2&gt;
&lt;p class=&quot;mb-p&quot;&gt;This site was created with the help of a static site generator: &lt;strong&gt;Jekyll&lt;/strong&gt;. Static site
    generators are really useful when content looks similar, which is exactly the case of a blog. That is why I decided
    to use Jekyll for this project. &lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;To style the site, I&apos;m using &lt;a href=&quot;https://tailwindcss.com&quot; class=&quot;link&quot;
        target=&quot;_blank&quot;&gt;TailwindCSS&lt;/a&gt;, which a css framework that is extremely useful for rapidly building a
    good-looking website. It works pretty much like a modern version of bootstrap. &lt;/p&gt;
&lt;p class=&quot;mb-p&quot;&gt;I think that the most interesting development choice of this project is using &lt;strong&gt;Github
        Actions&lt;/strong&gt; to compile and deploy the website. I had never used Github Actions, but there are many useful
    ressources online to learn how to use them. This Github feature allows you to quickly setupt actions to do things
    such as, in this case, automate the Jekyll build of my website. You&apos;ll find bellow a picture of what an &quot;action&quot;
    looks like. &lt;/p&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/githubactions.png&quot; alt=&quot;Screenshot of a Github Action&quot;&gt;


&lt;h2 class=&quot;text-xl mt-[30px] underline&quot;&gt;Final Project Idea #1&lt;/h2&gt;
&lt;p&gt;My first idea for the final project is to design a &lt;strong&gt;thrust vector control (TVC) &lt;/strong&gt; mount for model
    rockets. TVC allows rockets to change the direction of its thrust, and therefore its flight trajectory.&lt;/p&gt;
&lt;a class=&quot;mb-p link&quot; href=&quot;https://bps.space/&quot;&gt;&lt;img src=&quot;/phys_s12_blog/assets/images/tvcexample.jpg&quot;
        class=&quot;inline&quot;&gt; &lt;/a&gt;
&lt;p class=&quot;text-sm&quot;&gt;3D model of a TVC mount made by &lt;a href=&quot;https://www.youtube.com/@BPSspace&quot; class=&quot;link&quot;
        target=&quot;_blank&quot;&gt;bps.space&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To achieve a successfull project, I would need to succesfully develop a gimbal capable of holding a model rocket
    thruster, and a flight computer capable of detecting the orientation of the rocket (and therefore corret the
    trajectory).&lt;/p&gt;

&lt;h2 class=&quot;text-xl mt-[30px] underline&quot;&gt;Final Project Idea #2&lt;/h2&gt;

&lt;p&gt;My second final project idea is to design and build a &lt;strong&gt;3D printed RC car&lt;/strong&gt;. This project would require
    a lot of material testing (to make sure the different parts of the car are strong enough to sustain high speeds),
    and a lot of research to find the right components.
    That is I&apos;m more inclined to pursue my first idea, which would only require simple components (such as servos).&lt;/p&gt;
&lt;img src=&quot;/phys_s12_blog/assets/images/rccarexample.jpg&quot; class=&quot;inline mt-5&quot; width=&quot;50%&quot;&gt;
&lt;p class=&quot;text-sm&quot;&gt;Example of a 3d printed car made by &lt;a href=&quot;https://www.youtube.com/watch?v=r2UDc4A8huY&quot;
        class=&quot;link&quot; target=&quot;_blank&quot;&gt;Engineering Nonsense&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Website technology This site was created with the help of a static site generator: Jekyll. Static site generators are really useful when content looks similar, which is exactly the case of a blog. That is why I decided to use Jekyll for this project. To style the site, I&apos;m using TailwindCSS, which a css framework that is extremely useful for rapidly building a good-looking website. It works pretty much like a modern version of bootstrap. I think that the most interesting development choice of this project is using Github Actions to compile and deploy the website. I had never used Github Actions, but there are many useful ressources online to learn how to use them. This Github feature allows you to quickly setupt actions to do things such as, in this case, automate the Jekyll build of my website. You&apos;ll find bellow a picture of what an &quot;action&quot; looks like.</summary></entry></feed>